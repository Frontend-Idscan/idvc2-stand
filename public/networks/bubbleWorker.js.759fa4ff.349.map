{"version":3,"file":"bubbleWorker.js","mappings":"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","sources":["webpack://@idscan/idvc2/./src/helpers/image.ts","webpack://@idscan/idvc2/./src/constatnts/imageProcessing.ts","webpack://@idscan/idvc2/./src/workers/bubbleWorker.ts"],"sourcesContent":["import { ICrop } from './ts/common';\r\n\r\nexport type Base64Image = string;\r\nexport type RGBAColor = string;\r\nexport type RGBColor8 = Uint8ClampedArray;\r\nexport type RGBColor32 = Float32Array;\r\n\r\ntype PixelPosition = number;\r\ntype Position = (pixelPosition: PixelPosition, imageWidth: number) => PixelPosition;\r\ntype NeighboursPosition = (position: PixelPosition, width: number) => PixelPosition[];\r\ntype Segmentize = (binarizedImg: Uint8ClampedArray, width: number) => Set<PixelPosition>[];\r\ntype IsValidPixel = (pixel: PixelPosition) => boolean;\r\ntype Binarize = (img: ImageData, threshold?: number) => Uint8ClampedArray;\r\ntype GetResizedSizes = (size: number, baseSize: IBaseSize) => ISize;\r\n\r\nexport interface IOffset {\r\n  top: number,\r\n  left: number,\r\n}\r\n\r\n/**\r\n * { width: number, height: number }\r\n */\r\nexport interface ISize {\r\n  width: number,\r\n  height: number,\r\n}\r\ninterface IBaseSize {\r\n  baseWidth: number,\r\n  baseHeight: number,\r\n}\r\n\r\nexport const generateFaceColorFromAngle = (angle: number): RGBAColor => {\r\n  let color = Math.abs(Math.trunc(255 - angle));\r\n  if (color > 200) color = 200;\r\n  if (color < 50) color = 50;\r\n  return `rgba(255,215,${color.toString()},0.3)`;\r\n};\r\n\r\n/**\r\n *\r\n * @param {ImageData} iData\r\n * @param {number} threshold\r\n * @return number[] - black and whited array;\r\n */\r\nexport const binarize: Binarize = (iData, threshold = 120) => {\r\n  const setColor = 1;\r\n  const len = iData.width * iData.height;\r\n  const result = new Uint8ClampedArray(len);\r\n  let i;\r\n  let red = 0;\r\n  let green = 0;\r\n  let blue = 0;\r\n  let gray = 0;\r\n  for (i = 0; i < len; i += 1) {\r\n    // eslint-disable-next-line no-bitwise\r\n    const n = i << 2; // fast version of i * 4\r\n    red = iData.data[n + 0];\r\n    green = iData.data[n + 1];\r\n    blue = iData.data[n + 2];\r\n    // eslint-disable-next-line no-bitwise\r\n    gray = (77 * red + 151 * green + 28 * blue) >> 8;\r\n    if (gray < threshold) {\r\n      result[i] = setColor;\r\n    }\r\n  }\r\n  return result;\r\n};\r\n\r\nconst topPoint: Position = (position, width) => position - width;\r\nconst bottomPoint: Position = (position, width) => position + width;\r\nconst leftPoint: Position = (position, width) => (position % width > 1 ? position - 1 : -1);\r\nconst rightPoint: Position = (position, width) => ((position + 1) % width >= 0 ? position + 1 : -1);\r\nconst topLeftPoint: Position = (position, width) => leftPoint(\r\n  topPoint(position, width),\r\n  width,\r\n);\r\nconst topRightPoint: Position = (position, width) => rightPoint(\r\n  topPoint(position, width),\r\n  width,\r\n);\r\nconst bottomLeftPoint: Position = (position, width) => leftPoint(\r\n  bottomPoint(position, width),\r\n  width,\r\n);\r\nconst bottomRightPoint: Position = (position, width) => rightPoint(\r\n  bottomPoint(position, width),\r\n  width,\r\n);\r\n\r\nconst getNeigbors: NeighboursPosition = (position, width) => [\r\n  topLeftPoint,\r\n  topPoint,\r\n  topRightPoint,\r\n  rightPoint,\r\n  bottomRightPoint,\r\n  bottomPoint,\r\n  bottomLeftPoint,\r\n  leftPoint,\r\n].map((fn) => fn(position, width));\r\n\r\nexport const segmentize2: Segmentize = (binarizedImg, width) => {\r\n  const queue: number[] = [];\r\n  const segments: Set<number>[] = [];\r\n  const imgLen = binarizedImg.length;\r\n  let segmentIdx = 0;\r\n  let pixelIdx: number;\r\n\r\n  const search = (): void => {\r\n    const isValidPixel: IsValidPixel = (el) => el > 0\r\n      && binarizedImg[el] !== 0\r\n      && el < imgLen;\r\n    while (queue.length) {\r\n      const centerPixelIdx = queue.pop();\r\n      if (!centerPixelIdx) break;\r\n      // eslint-disable-next-line no-param-reassign\r\n      binarizedImg[centerPixelIdx] = 0;\r\n      segments[segmentIdx].add(centerPixelIdx);\r\n      getNeigbors(centerPixelIdx, width)\r\n        .forEach((el) => {\r\n          if (isValidPixel(el)) {\r\n            queue.push(el);\r\n          }\r\n        });\r\n    }\r\n  };\r\n\r\n  for (pixelIdx = 0; pixelIdx < imgLen; pixelIdx += 1) {\r\n    // eslint-disable-next-line no-continue\r\n    if (binarizedImg[pixelIdx] === 0) continue;\r\n    segments[segmentIdx] = new Set();\r\n    queue.push(pixelIdx);\r\n    search();\r\n    segmentIdx += 1;\r\n  }\r\n\r\n  return segments;\r\n};\r\n\r\nexport const getResizedSizes: GetResizedSizes = (size, { baseWidth, baseHeight }) => {\r\n  let width = size;\r\n  let height = size;\r\n  if (baseWidth > baseHeight) {\r\n    width = size;\r\n    height = (width * baseHeight) / baseWidth;\r\n  }\r\n  if (baseHeight > baseWidth) {\r\n    height = size;\r\n    width = (height * baseWidth) / baseHeight;\r\n  }\r\n  return {\r\n    width: Math.trunc(width),\r\n    height: Math.trunc(height),\r\n  };\r\n};\r\n\r\nexport const getCrop = (src: ISize, dst: ISize): ICrop => {\r\n  const srcWidth = src.width;\r\n  const srcHeight = src.height;\r\n  const aspectRatioSrc = srcWidth / srcHeight; // float\r\n  const aspectRatioDst = dst.width / dst.height; // float\r\n  const targetCrop: ICrop = {\r\n    x: 0, y: 0, width: dst.width, height: dst.height,\r\n  };\r\n  if (aspectRatioSrc > aspectRatioDst) {\r\n    targetCrop.height = ~~(dst.width / aspectRatioSrc);\r\n    targetCrop.y = (dst.height - targetCrop.height) / 2;\r\n  } else {\r\n    targetCrop.width = ~~(targetCrop.height * aspectRatioSrc);\r\n    targetCrop.x = (dst.width - targetCrop.width) / 2;\r\n  }\r\n  return targetCrop;\r\n};\r\n","export const POINT_FILL_STYLE = 'rgba(255, 255, 255, 0.5)';\r\nexport const POINT_STROKE_STYLE = 'rgba(255, 255, 255, 0)';\r\nexport const SCALE_FACTOR = 0.3;\r\n","import {\r\n  BubbleWorkerMessage, CoordinateSegment, PixelPosition, PointsProcess, Segment,\r\n} from '../types/workers/BubbleWorkerMessage';\r\nimport { binarize, segmentize2 } from '../helpers/image';\r\nimport { SCALE_FACTOR } from '../constatnts/imageProcessing';\r\nimport { Point } from '../helpers/geometry';\r\n\r\nconst getColumn = (d: number, w: number) => d % w;\r\n\r\nconst getRow = (d: number, w: number) => Math.floor(d / w);\r\n\r\nconst createCoordFromPointIdx = (pixelPosition: PixelPosition, width: number): Point => [\r\n  getColumn(pixelPosition, width),\r\n  getRow(pixelPosition, width),\r\n];\r\n\r\nconst notNull = <T> (value: T | null | undefined): value is T => value !== null\r\n  && value !== undefined;\r\n\r\nconst coordinateSegment: CoordinateSegment = ({\r\n  segments,\r\n  width,\r\n  scaleWidth,\r\n  scaleHeight,\r\n}) => {\r\n  const MIN_PERIMETER = 5;\r\n  const MAX_PERIMETER = 500;\r\n\r\n  return segments.map((segment): Segment | null => {\r\n    let minX = Number.MAX_VALUE; // ignoring case of empty list for conciseness\r\n    let minY = Number.MAX_VALUE;\r\n    let maxX = Number.MIN_VALUE;\r\n    let maxY = Number.MIN_VALUE;\r\n    segment.forEach((position) => {\r\n      const coord = createCoordFromPointIdx(position, width);\r\n      if (coord[0] < minX) minX = coord[0];\r\n      if (coord[1] < minY) minY = coord[1];\r\n      if (coord[0] > maxX) maxX = coord[0];\r\n      if (coord[1] > maxY) maxY = coord[1];\r\n    });\r\n    const per = (maxX - minX) * (maxY - minY);\r\n    if (per > MIN_PERIMETER && per < MAX_PERIMETER) {\r\n      return {\r\n        perimeter: per,\r\n        x1: Math.trunc((minX / SCALE_FACTOR) / scaleWidth),\r\n        y1: Math.trunc((minY / SCALE_FACTOR) / scaleHeight),\r\n        x2: Math.trunc((maxX / SCALE_FACTOR) / scaleWidth),\r\n        y2: Math.trunc((maxY / SCALE_FACTOR) / scaleHeight),\r\n      };\r\n    }\r\n    return null;\r\n  }).filter(notNull);\r\n};\r\n\r\nconst pointsProcess: PointsProcess = (iData, scaleWidth, scaleHeight) => {\r\n  const bin = binarize(iData);\r\n\r\n  return coordinateSegment({\r\n    segments: segmentize2(bin, iData.width),\r\n    width: iData.width,\r\n    scaleWidth,\r\n    scaleHeight,\r\n  });\r\n};\r\n\r\nonmessage = ({ data }: MessageEvent<BubbleWorkerMessage>) => {\r\n  if (data && data.iData) {\r\n    const segments = pointsProcess(\r\n      data.iData,\r\n      data.resizedToBorderScaleWidth,\r\n      data.resizedToBorderScaleHeight,\r\n    );\r\n    postMessage({ segments });\r\n  }\r\n};\r\n"],"names":["generateFaceColorFromAngle","angle","color","Math","abs","trunc","toString","binarize","iData","threshold","setColor","len","width","height","result","Uint8ClampedArray","i","red","green","blue","gray","n","data","topPoint","position","bottomPoint","leftPoint","rightPoint","topLeftPoint","topRightPoint","bottomLeftPoint","bottomRightPoint","getNeigbors","map","fn","segmentize2","binarizedImg","queue","segments","imgLen","length","segmentIdx","pixelIdx","search","isValidPixel","el","centerPixelIdx","pop","add","forEach","push","Set","getResizedSizes","size","baseWidth","baseHeight","getCrop","src","dst","srcWidth","srcHeight","aspectRatioSrc","aspectRatioDst","targetCrop","x","y","POINT_FILL_STYLE","POINT_STROKE_STYLE","SCALE_FACTOR","getColumn","d","w","getRow","floor","createCoordFromPointIdx","pixelPosition","notNull","value","undefined","coordinateSegment","scaleWidth","scaleHeight","MIN_PERIMETER","MAX_PERIMETER","segment","minX","Number","MAX_VALUE","minY","maxX","MIN_VALUE","maxY","coord","per","perimeter","x1","y1","x2","y2","filter","pointsProcess","bin","onmessage","resizedToBorderScaleWidth","resizedToBorderScaleHeight","postMessage"],"sourceRoot":""}